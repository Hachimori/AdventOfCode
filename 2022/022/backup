#!/usr/bin/env python

import copy

SZ = 4 # 50
BOTTOM = 0
RIGHT = 1
TOP = 2
LEFT = 3
FRONT = 4
BACK = 5
dr = [-1, 0, 1, 0]
dc = [0, 1, 0, -1]


def read():
    lines = []    
    while 1:
        line = raw_input()
        if not line:
            break
        lines.append(line)
    return lines, raw_input()


def createMaze(lines):
    maze = []
    col = max(len(line) for line in lines)
    for line in lines:
        maze.append(line + ' ' * (col - len(line)))
    return maze


def swapFace(faceIdx1, faceIdx2, cube, cubePt):
    for r in range(SZ):
        for c in range(SZ):
            cube[faceIdx1][r][c], cube[faceIdx2][r][c] = cube[faceIdx2][r][c], cube[faceIdx1][r][c]
            cubePt[faceIdx1][r][c], cubePt[faceIdx2][r][c] = cubePt[faceIdx2][r][c], cubePt[faceIdx1][r][c]

def rotateFaceRight(acePt):
    buf = [[' ' for c in range(SZ)] for r in range(SZ)]
    for r in range(SZ):
        for c in range(SZ):
            buf[c][SZ - 1 - r] = facePt[r][c]
    for r in range(SZ):
        for c in range(SZ):
            facePt[r][c] = buf[r][c]

def rotateFaceLeft(face):
    rotateFaceRight(face)
    rotateFaceRight(face)
    rotateFaceRight(face)

def rotateCubeRight(cube):
    swapFace(BOTTOM, RIGHT, cube)
    swapFace(RIGHT, TOP, cube)
    swapFace(TOP, LEFT, cube)
    rotateFaceRight(cube[FRONT])
    rotateFaceLeft(cube[BACK])

def rotateCubeLeft(cube):
    rotateCubeRight(cube)
    rotateCubeRight(cube)
    rotateCubeRight(cube)

def rotateCubeFront(cube):
    swapFace(BOTTOM, FRONT, cube)
    swapFace(FRONT, TOP, cube)
    swapFace(TOP, BACK, cube)
    rotateFaceLeft(cube[RIGHT])
    rotateFaceRight(cube[LEFT])

def rotateCubeBack(cube):
    rotateCubeFront(cube)
    rotateCubeFront(cube)
    rotateCubeFront(cube)


def dfs(mazeR, mazeC, cubeR, cubeC, cube, visited, maze):
    visited[mazeR][mazeC] = True
    cube[BOTTOM][cubeR][cubeC] = (mazeR, mazeC)

    for i in range(6):
        print ["BOTTOM", "RIGHT", "TOP", "LEFT", "FRONT", "BACK"][i]
        for r in range(SZ):
            for c in range(SZ):
                print cube[i][r][c],
            print ""
        print ""
    print ""
    
    for i in range(4):
        mazeNR = mazeR + dr[i]
        mazeNC = mazeC + dc[i]
        cubeNR = cubeR + dr[i]
        cubeNC = cubeC + dc[i]
        
        if not (0 <= mazeNR < len(maze) and 0 <= mazeNC < len(maze[0])):
            continue

        if maze[mazeNR][mazeNC] == ' ':
            continue
        
        if visited[mazeNR][mazeNC]:
            continue

        if cubeNR == -1:
            rotateCubeBack(cube)
            dfs(mazeNR, mazeNC, SZ - 1, cubeNC, cube, visited, maze)
            rotateCubeFront(cube)
        elif cubeNR == SZ:
            rotateCubeFront(cube)
            dfs(mazeNR, mazeNC, 0, cubeNC, cube, visited, maze)
            rotateCubeBack(cube)
        elif cubeNC == -1:
            rotateCubeLeft(cube)
            dfs(mazeNR, mazeNC, cubeNR, SZ - 1, cube, visited, maze)
            rotateCubeRight(cube)
        elif cubeNC == SZ:
            rotateCubeRight(cube)
            dfs(mazeNR, mazeNC, cubeNR, 0, cube, visited, maze)
            rotateCubeLeft(cube)
        else:
            dfs(mazeNR, mazeNC, cubeNR, cubeNC, cube, visited, maze)


def createCube(maze):
    cube = [[[(-1, -1) for k in range(SZ)] for j in range(SZ)] for i in range(6)]
    visited = [[False for c in range(len(maze[0]))] for r in range(len(maze))]
    
    initR = 0
    initC = maze[0].index('.')
    
    dfs(initR, initC, 0, 0, cube, visited, maze)

    return cube


def createMove(moveStr):
    move = []
    for i in range(len(moveStr)):
        if moveStr[i].isalpha():
            move.append(moveStr[i])
        elif move and move[-1].isdigit():
            move[-1] += moveStr[i]
        else:
            move.append(moveStr[i])
        
    for i in range(len(move)):
        if move[i].isdigit():
            move[i] = int(move[i])
    
    return move


def getNextRC(cubeR, cubeC, to, cube):
    dr = [0, 1, 0, -1]
    dc = [1, 0, -1, 0]

    cubeNR = cubeR + dr[to]
    cubeNC = cubeC + dc[to]
    
    if cubeNR == -1:
        rotateCubeBack(cube)
        cubeNR = SZ - 1
    elif cubeNR == SZ:
        rotateCubeFront(cube)
        cubeNR = 0
    elif cubeNC == -1:
        rotateCubeLeft(cube)
        cubeNC = SZ - 1
    elif cubeNC == SZ:
        rotateCubeRight(cube)
        cubeNC = 0

    return cubeNR, cubeNC

    
def work((lines, moveStr)):
    maze = createMaze(lines)
    cube = createCube(maze)
    moves = createMove(moveStr)
    row, col = len(maze), len(maze[0])

    '''
    for i in range(6):
        print ["BOTTOM", "RIGHT", "TOP", "LEFT", "FRONT", "BACK"][i]
        for r in range(SZ):
            for c in range(SZ):
                print cube[i][r][c],
            print ""
        print ""
    '''
    
    cubeR = 0
    cubeC = 0
    to = 0

    for move in moves:
        if move == 'R':
            to = (to + 1) % 4
        elif move == 'L':
            to = (to + 3) % 4
        else:
            for _ in range(move):
                backup = copy.deepcopy(cube)
                
                cubeNR, cubeNC = getNextRC(cubeR, cubeC, to, cube)
                mazeNR, mazeNC = cube[BOTTOM][cubeNR][cubeNC]
                if maze[mazeNR][mazeNC] == '#':
                    cube = backup
                    break
                cubeR, cubeC = cubeNR, cubeNC
                print mazeNR, mazeNC

    mazeR, mazeC = cube[BOTTOM][cubeNR][cubeNC]
    if 0 <= cubeR + dr[to] < SZ and 0 <= cubeC + dc[to] < SZ:
        r1, c1 = cube[BOTTOM][cubeR][cubeC]
        r2, c2 = cube[BOTTOM][cubeR + dr[to]][cubeC + dc[to]]
        diffR, diffC = r2 - r1, c2 - c1
    else:
        r1, c1 = cube[BOTTOM][cubeR - dr[to]][cubeC - dc[to]]
        r2, c2 = cube[BOTTOM][cubeR][cubeC]
        diffR, diffC = r2 - r1, c2 - c1
    drdc2to = {(0, 1): 0, (1, 0): 1, (0, -1): 2, (-1, 0): 3}
    print (mazeR + 1) * 1000 + (mazeC + 1) * 4 + drdc2to[(diffR, diffC)]
    
    
if __name__ == "__main__":
    work(read())
